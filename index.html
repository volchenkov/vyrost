<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>VYROST game</title>
    <style>
    	* {
            padding: 0;
            margin: 0;
        }
    	canvas { 
            background: #eee;
            display: block;
        }
    </style>
</head>
<body>

<canvas id="canvas"></canvas>

<script>
    let canvas = document.getElementById("canvas");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    let ctx = canvas.getContext("2d");

    let config = { 
        DEFAULT_X_SIZE: 10,
        DEFAULT_Y_SIZE: 10,
        DEFAULT_FOOD_Y_SIZE: 10,
        DEFAULT_FOOD_X_SIZE: 10,
        INIT_FOOD_COUNT: 25,
        NPC_CREATURES_COUNT: 10,
    };

    const kbrdCtrl = {u: false, d: false, l: false, r: false};

    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);

    let creatures = [];

    let pCreature = createCreature(false);

    pCreature.speedX = pCreature.maxSpeed;
    pCreature.speedY = pCreature.maxSpeed;
    pCreature.x = canvas.width / 2 - pCreature.sizeX / 2;
    pCreature.y = canvas.height - pCreature.sizeY * 1.2;

    creatures.push(pCreature);

    let food = [];

    function drawCreatures(ctx, creatures) {
        creatures.forEach(c => {
            ctx.beginPath();
            ctx.rect(c.x, c.y, c.sizeX, c.sizeY);
            ctx.fillStyle = c.skin;
            ctx.fill();
            ctx.closePath();
        });
    }

    function drawFood(ctx, food) {
        food.forEach(f => {
            ctx.beginPath();
            ctx.rect(f.x, f.y, f.sizeX, f.sizeY);
            ctx.fillStyle = "#43DF39";
            ctx.fill();
            ctx.closePath();
        });
    }

    function collideFood(creatures, food) {
        creatures.forEach(c => {
            food.forEach((f, i) => {
                if (Math.abs(c.x - f.x) <= c.sizeX && Math.abs(c.y - f.y) <= c.sizeY) {
                    c.eat(food);
                    food.splice(i, 1);
                }
            })
        })
    }

    function tick() {

        if (kbrdCtrl.r) {
            pCreature.speedX = pCreature.maxSpeed;
        } else if (kbrdCtrl.l) {
            pCreature.speedX = -pCreature.maxSpeed;
        } else {
            pCreature.speedX = 0; 
        }

        if (kbrdCtrl.u) {
            pCreature.speedY = -pCreature.maxSpeed;
        } else if (kbrdCtrl.d) {
            pCreature.speedY = pCreature.maxSpeed;
        } else {
            pCreature.speedY = 0;
        }

        collideFood(creatures, food);

        creatures
            .forEach(c => {
                if (c.x + c.speedX > canvas.width - c.sizeX || c.x + c.speedX < 0) {
                    c.speedX = -c.speedX;
                }
                if (c.y + c.speedY > canvas.height - c.sizeY || c.y + c.speedY < 0) {
                    c.speedY = -c.speedY;
                }

                c.x += c.speedX;
                c.y += c.speedY;
            });
        
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawFood(ctx, food);
        drawCreatures(ctx, creatures);

        requestAnimationFrame(tick);
    }


    function keyDownHandler(e) {
        if (e.key == "Right" || e.key == "ArrowRight") {
            kbrdCtrl.r = true;
        } 
        else if (e.key == "Left" || e.key == "ArrowLeft") {
            kbrdCtrl.l = true;
        }
        else if (e.key == "Up" || e.key == "ArrowUp") {
            kbrdCtrl.u = true;
        }
        else if (e.key == 'Down' || e.key == 'ArrowDown') {
            kbrdCtrl.d = true;
        }
    }

    function keyUpHandler(e) {
        if (e.key == "Right" || e.key == "ArrowRight") {
            kbrdCtrl.r = false;
        } 
        else if (e.key == "Left" || e.key == "ArrowLeft") {
            kbrdCtrl.l = false;
        }
        else if (e.key == "Up" || e.key == "ArrowUp") {
            kbrdCtrl.u = false;
        }
        else if (e.key == 'Down' || e.key == 'ArrowDown') {
            kbrdCtrl.d = false;
        }
    }

    for (let j = 0; j <= config.NPC_CREATURES_COUNT; j++) {
        let c = createCreature(true)

        c.x = rnd(c.sizeX, canvas.width - c.sizeX);
        c.y = rnd(c.sizeY, canvas.height - c.sizeY);

        creatures.push(c);
    }

    for (let i = 0; i <= config.INIT_FOOD_COUNT; i++) {
        let f = {
            sizeX: config.DEFAULT_FOOD_X_SIZE,
            sizeY: config.DEFAULT_FOOD_Y_SIZE,
            value: 10
        }
        f.x = rnd(f.sizeX, canvas.width - f.sizeX)
        f.y = rnd(f.sizeY, canvas.height - f.sizeY)
        
        food.push(f)
    }
    
    tick();


    function createCreature(npc) {
        let rndBlue = () => `hsl(240, ${rnd(30, 80)}%, ${rnd(30, 80)}%)`;

        const maxSpeed = rnd(1, 10); 

        let c = {
            sizeX: config.DEFAULT_X_SIZE,
            sizeY: config.DEFAULT_Y_SIZE,
            maxSpeed: maxSpeed,
            speedX: plusOrMinus() * maxSpeed,
            speedY: plusOrMinus() * maxSpeed,
            skin: !npc ? '#FF008F' : rndBlue(),
            x: 0,
            y: 0,
            satiety: 100,
            npc: npc,
        }

        c.eat = (food) => {
            c.satiety += food.value;
            
            c.sizeX = c.sizeX * 1.3;
            c.sizeY = c.sizeY * 1.3;
        } 

        return c;
    }

    function rnd(min, max) {
        return Math.random() * (max - min) + min;
    }

    function plusOrMinus() {
        return Math.random() < 0.5 ? -1 : 1;
    }
</script>

</body>
</html>