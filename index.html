<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>VYROST game</title>
    <style>
    	* {
            padding: 0;
            margin: 0;
        }
    	canvas { 
            background: #eee;
            display: block;
            margin: 0 auto;
            margin-top: 50px;
        }
    </style>
</head>
<body>

<canvas id="canvas" width="560" height="560"></canvas>

<script>
    let canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");

    let config = { 
        DEFAULT_X_SIZE: 10,
        DEFAULT_Y_SIZE: 10,
        DEFAULT_FOOD_Y_SIZE: 10,
        DEFAULT_FOOD_X_SIZE: 10,
        INIT_FOOD_COUNT: 10,
        NPC_CREATURES_COUNT: 10,
    };

    const kbrdCtrl = {u: false, d: false, l: false, r: false};

    document.addEventListener("keydown", keyDownHandler, false);
    document.addEventListener("keyup", keyUpHandler, false);

    let creatures = [];

    let pCreature = createCreature(false);

    pCreature.maxSpeed = 10;
    pCreature.speedX = pCreature.maxSpeed / 2;
    pCreature.speedY = pCreature.maxSpeed / 2;
    pCreature.x = canvas.width / 2 - config.DEFAULT_X_SIZE / 2;
    pCreature.y = canvas.height - config.DEFAULT_Y_SIZE * 2;

    creatures.push(pCreature);

    let food = [];

    function drawCreatures(ctx, creatures) {
        creatures.forEach(c => {
            ctx.beginPath();
            ctx.rect(c.x, c.y, c.sizeX, c.sizeY);
            ctx.fillStyle = c.skin;
            ctx.fill();
            ctx.closePath();
        });
    }

    function drawFood(ctx, food) {
        food.forEach(f => {
            ctx.beginPath();
            ctx.rect(f.x, f.y, f.sizeX, f.sizeY);
            ctx.fillStyle = "#43DF39";
            ctx.fill();
            ctx.closePath();
        });
    }

    function collideFood(creatures, food) {
        creatures.forEach(c => {
            food.forEach((f, i) => {
                if (Math.abs(c.x - f.x) <= c.sizeX && Math.abs(c.y - f.y) <= c.sizeY) {
                    c.eat(food);
                    food.splice(i, 1);
                }
            })
        })
    }

    function tick() {

        if (kbrdCtrl.r) {
            pCreature.speedX = pCreature.maxSpeed / 2;
        } else if (kbrdCtrl.l) {
            pCreature.speedX = -pCreature.maxSpeed / 2;
        } else {
            pCreature.speedX = 0; 
        }

        if (kbrdCtrl.u) {
            pCreature.speedY = -pCreature.maxSpeed / 2;
        } else if (kbrdCtrl.d) {
            pCreature.speedY = pCreature.maxSpeed / 2;
        } else {
            pCreature.speedY = 0;
        }

        creatures
            .forEach(c => {
                if (c.x + c.speedX > canvas.width - c.sizeX || c.x + c.speedX < c.sizeX) {
                    c.speedX = -c.speedX;
                }
                if (c.y + c.speedY > canvas.height - c.sizeY || c.y + c.speedY < c.sizeY) {
                    c.speedY = -c.speedY;
                }

                c.x += c.speedX;
                c.y += c.speedY;
            });
        
        collideFood(creatures, food);

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawFood(ctx, food);
        drawCreatures(ctx, creatures);

        requestAnimationFrame(tick);
    }


    function keyDownHandler(e) {
        if (e.key == "Right" || e.key == "ArrowRight") {
            kbrdCtrl.r = true;
        } 
        else if (e.key == "Left" || e.key == "ArrowLeft") {
            kbrdCtrl.l = true;
        }
        else if (e.key == "Up" || e.key == "ArrowUp") {
            kbrdCtrl.u = true;
        }
        else if (e.key == 'Down' || e.key == 'ArrowDown') {
            kbrdCtrl.d = true;
        }
    }

    function keyUpHandler(e) {
        if (e.key == "Right" || e.key == "ArrowRight") {
            kbrdCtrl.r = false;
        } 
        else if (e.key == "Left" || e.key == "ArrowLeft") {
            kbrdCtrl.l = false;
        }
        else if (e.key == "Up" || e.key == "ArrowUp") {
            kbrdCtrl.u = false;
        }
        else if (e.key == 'Down' || e.key == 'ArrowDown') {
            kbrdCtrl.d = false;
        }
    }

    for (let j = 0; j <= config.NPC_CREATURES_COUNT; j++) {
        let c = createCreature(true)

        c.x = rnd(c.sizeX, canvas.width - c.sizeX);
        c.y = rnd(c.sizeY, canvas.height - c.sizeY);

        creatures.push(c);
    }

    for (let i = 0; i <= config.INIT_FOOD_COUNT; i++) {
        let f = {
            sizeX: config.DEFAULT_FOOD_X_SIZE,
            sizeY: config.DEFAULT_FOOD_Y_SIZE,
            value: 10
        }
        f.x = rnd(f.sizeX, canvas.width - f.sizeX)
        f.y = rnd(f.sizeY, canvas.height - f.sizeY)
        
        food.push(f)
    }
    
    tick();


    function createCreature(npc) {
        let rndBlue = () => `hsl(240, ${rnd(30, 80)}%, ${rnd(30, 80)}%)`;

        const maxSpeed = rnd(1, 6); 

        let c = {
            sizeX: config.DEFAULT_X_SIZE,
            sizeY: config.DEFAULT_Y_SIZE,
            maxSpeed: maxSpeed,
            speedX: plusOrMinus() * rnd(1, maxSpeed),
            speedY: plusOrMinus() * rnd(1, maxSpeed),
            skin: !npc ? '#FF008F' : rndBlue(),
            x: 0,
            y: 0,
            satiety: 100,
            npc: npc,
        }

        c.eat = (food) => {
            c.satiety += food.value;
        } 

        return c;
    }

    function rnd(min, max) {
        return Math.random() * (max - min) + min;
    }

    function plusOrMinus() {
        return Math.random() < 0.5 ? -1 : 1;
    }
</script>
<!-- <script>
var canvas = document.getElementById("canvas2");

var ctx = canvas.getContext("2d");
var ballRadius = 10;
var x = canvas.width/2;
var y = canvas.height-30;
var dx = 2;
var dy = -2;
var paddleHeight = 10;
var paddleWidth = 75;
var paddleX = (canvas.width-paddleWidth)/2;
var rightPressed = false;
var leftPressed = false;
var brickRowCount = 5;
var brickColumnCount = 3;
var brickWidth = 75;
var brickHeight = 20;
var brickPadding = 10;
var brickOffsetTop = 30;
var brickOffsetLeft = 30;
var score = 0;
var lives = 3;

var bricks = [];
for(var c=0; c<brickColumnCount; c++) {
  bricks[c] = [];
  for(var r=0; r<brickRowCount; r++) {
    bricks[c][r] = { x: 0, y: 0, status: 1 };
  }
}

document.addEventListener("keydown", keyDownHandler, false);
document.addEventListener("keyup", keyUpHandler, false);
document.addEventListener("mousemove", mouseMoveHandler, false);

function keyDownHandler(e) {
    if(e.key == "Right" || e.key == "ArrowRight") {
        rightPressed = true;
    }
    else if(e.key == "Left" || e.key == "ArrowLeft") {
        leftPressed = true;
    }
}

function keyUpHandler(e) {
    if(e.key == "Right" || e.key == "ArrowRight") {
        rightPressed = false;
    }
    else if(e.key == "Left" || e.key == "ArrowLeft") {
        leftPressed = false;
    }
}

function mouseMoveHandler(e) {
  var relativeX = e.clientX - canvas.offsetLeft;
  if(relativeX > 0 && relativeX < canvas.width) {
    paddleX = relativeX - paddleWidth/2;
  }
}
function collisionDetection() {
  for(var c=0; c<brickColumnCount; c++) {
    for(var r=0; r<brickRowCount; r++) {
      var b = bricks[c][r];
      if(b.status == 1) {
        if(x > b.x && x < b.x+brickWidth && y > b.y && y < b.y+brickHeight) {
          dy = -dy;
          b.status = 0;
          score++;
          if(score == brickRowCount*brickColumnCount) {
            alert("YOU WIN, CONGRATS!");
            document.location.reload();
          }
        }
      }
    }
  }
}

function drawBall() {
  ctx.beginPath();
  ctx.arc(x, y, ballRadius, 0, Math.PI*2);
  ctx.fillStyle = "#0095DD";
  ctx.fill();
  ctx.closePath();
}
function drawPaddle() {
  ctx.beginPath();
  ctx.rect(paddleX, canvas.height-paddleHeight, paddleWidth, paddleHeight);
  ctx.fillStyle = "#0095DD";
  ctx.fill();
  ctx.closePath();
}
function drawBricks() {
  for(var c=0; c<brickColumnCount; c++) {
    for(var r=0; r<brickRowCount; r++) {
      if(bricks[c][r].status == 1) {
        var brickX = (r*(brickWidth+brickPadding))+brickOffsetLeft;
        var brickY = (c*(brickHeight+brickPadding))+brickOffsetTop;
        bricks[c][r].x = brickX;
        bricks[c][r].y = brickY;
        ctx.beginPath();
        ctx.rect(brickX, brickY, brickWidth, brickHeight);
        ctx.fillStyle = "#0095DD";
        ctx.fill();
        ctx.closePath();
      }
    }
  }
}
function drawScore() {
  ctx.font = "16px Arial";
  ctx.fillStyle = "#0095DD";
  ctx.fillText("Score: "+score, 8, 20);
}
function drawLives() {
  ctx.font = "16px Arial";
  ctx.fillStyle = "#0095DD";
  ctx.fillText("Lives: "+lives, canvas.width-65, 20);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawBricks();
  drawBall();
  drawPaddle();
  drawScore();
  drawLives();
  collisionDetection();

  if(x + dx > canvas.width-ballRadius || x + dx < ballRadius) {
    dx = -dx;
  }
  if(y + dy < ballRadius) {
    dy = -dy;
  }
  else if(y + dy > canvas.height-ballRadius) {
    if(x > paddleX && x < paddleX + paddleWidth) {
      dy = -dy;
    }
    else {
      lives--;
      if(!lives) {
        alert("GAME OVER");
        document.location.reload();
      }
      else {
        x = canvas.width/2;
        y = canvas.height-30;
        dx = 3;
        dy = -3;
        paddleX = (canvas.width-paddleWidth)/2;
      }
    }
  }

  if(rightPressed && paddleX < canvas.width-paddleWidth) {
    paddleX += 7;
  }
  else if(leftPressed && paddleX > 0) {
    paddleX -= 7;
  }

  x += dx;
  y += dy;
  requestAnimationFrame(draw);
}

draw();
</script> -->

</body>
</html>